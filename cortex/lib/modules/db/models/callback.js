'use strict'

/*!
 * @todo move to EventEmitter model for better registration? test how mongoosejs objects handle emitters on schema statics

 * @todo hash callback tokens?
 * @todo use pre('validate') to ensure token value never changes
 */

const { isSet, path: pathTo } = require('../../../utils'),
      config = require('cortex-service/lib/config'),
      Fault = require('cortex-service/lib/fault'),
      modules = require('../../index'),
      async = require('async')

module.exports = function(mongoose) {

  const callbackSchema = new mongoose.Schema({

    org: {
      type: mongoose.Schema.Types.ObjectId
    },
    handler: {
      type: String
    },
    sender: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'account'
    },
    token: {
      type: String
    },
    clientKey: {
      type: String
    },
    state: {
      type: String
    },
    target: { // the email target.
      type: String,
      lowercase: true
    },
    targetId: { // the target accountId, if exists.
      type: mongoose.Schema.Types.ObjectId
    },
    reason: { // a code or message specifying the reason for the state.
      type: String
    },
    expires: { // the date the callback expires. missing if persistent.
      type: Date
    },
    context: {
      object: {
        type: String
      },
      _id: { // allows callback handlers to classify tokens. not required, but is indexed.
        type: mongoose.Schema.Types.ObjectId
      }
    },
    data: { // optional arbitrary user data passed in on callback creation.
      type: mongoose.Schema.Types.Mixed
    }
  }, {
    versionKey: false
  })

  callbackSchema.index({ org: 1, handler: 1, sender: 1, targetId: 1, 'context._id': 1 }, { name: 'idxContextTarget' })
  callbackSchema.index({ target: 1 }, { name: 'idxTarget' })
  callbackSchema.index({ token: 1 }, { unique: true, name: 'idxToken' })
  callbackSchema.index({ expires: 1 }, { name: 'idxExpires', expireAfterSeconds: 0 })
  callbackSchema.index({ 'context.object': 1 }, { partialFilterExpression: { 'context.object': { $exists: true } }, name: 'idxContextObject' })

  callbackSchema.virtual('persistent').get(function() {
    return !this.expires
  })

  callbackSchema.virtual('expired').get(function() {
    return !this.persistent && (this.expires && (this.expires.getTime() < new Date().getTime()))
  })

  // ------------------------------------------------------------------------

  /**
     *
     * @param org this can be null for callbacks that aren't org-dependent (like location and account verifications)
     * @param handler the name of a registered handler to receive callback events.
     * @param senderId the account that created the token.
     * @param target the target's email address
     * @param options
     *          {
     *              expiresMs: Number (optional, defaults to app.config.callbacks.defaultExpiryMs),
     *              persistent: Boolean (optional. defaults to false. persistent tokens can be used over and over),
     *              targetId: ObjectId (optional). the target account id, if available.
     *              data: Mixed (optional. some optional user data that is passed to the handler. keep it small!),
     *              objectName: optional object name,
     *              token: an overriding token generated by the caller,
     *              clientKey: app key that generates the callback.
     *              contextId: optional context Id,
     *              allowDuplicates: false, (optional)
     *              includeUserDataInDuplicateCheck: false (optional)
     *              updateToken: true (only works with allowDuplicates==false. updates to a new token)
     *              updateData: true (only works with allowDuplicates==false. updates the data.)
     *          }
     *
     * @param callback -> err, callbackObject, duplicate
     */
  callbackSchema.statics.createCallback = function(org, handler, senderId, target, options, callback) {

    options = options || {}
    if (options.updateData == null) options.updateData = true
    const self = this,
          orgId = org._id,
          clientKey = org.keyToClient(options.clientKey)?.key

    target = String(target).toLowerCase()

    async.waterfall([

      function(callback) {
        if (options.allowDuplicates) {
          callback(null)
        } else {
          const find = { org: orgId, handler: handler, sender: senderId, state: 'pending', target: target },
                set = {}
          if (options.objectName) {
            find['context.object'] = options.objectName
          } else {
            find['context.object'] = { $exists: false }
          }
          if (options.contextId) {
            find['context._id'] = options.contextId
          } else {
            find['context._id'] = { $exists: false }
          }
          if (options.targetId) {
            find.targetId = options.targetId
          } else {
            find.targetId = { $exists: false }
          }
          if (options.includeUserDataInDuplicateCheck && options.data) find.data = options.data

          if (isSet(clientKey)) set.clientKey = clientKey
          if (!options.persistent) set.expires = new Date(new Date().getTime() + (options.expiresMs || config('callbacks.defaultExpiryMs')))
          if (!options.includeUserDataInDuplicateCheck && options.updateData && options.data) set.data = options.data
          if (options.updateToken) set.token = options.token || modules.authentication.genAlphaNumString(config('callbacks.tokenLength'))
          if (Object.keys(set).length > 0) {
            self.findOneAndUpdate(find, { $set: set }, { returnDocument: 'after' }, callback)
          } else {
            self.findOne(find, callback)
          }
        }
      },

      function(doc, callback) {

        if (doc) {
          callback(null, doc, true)
        } else {
          var modelData = { org: orgId, handler: handler, sender: senderId, state: 'pending', target: target, token: options.token || modules.authentication.genAlphaNumString(config('callbacks.tokenLength')) }
          if (options.objectName) pathTo(modelData, 'context.object', options.objectName)
          if (options.contextId) pathTo(modelData, 'context._id', options.contextId)
          if (isSet(clientKey)) modelData.clientKey = clientKey
          if (options.targetId) modelData.targetId = options.targetId
          if (!options.persistent) modelData.expires = new Date(new Date().getTime() + (options.expiresMs || config('callbacks.defaultExpiryMs')))
          if (options.data) modelData.data = options.data
          self.create(modelData, function(err, doc) {
            callback(err, doc, false)
          })
        }
      }

    ], function(err, doc, duplicate) {
      callback(Fault.from(err), doc, duplicate)
    })

  }

  return callbackSchema

}
